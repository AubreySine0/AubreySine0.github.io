<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Segment Plugin Test Site</title>
  
  <!-- Your existing OneTrust setup -->
  <script
    src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"
    type="text/javascript"
    charset="UTF-8"
    data-domain-script="01929b9b-c505-7cd6-9ca1-67e5e5aa979e"
  ></script>
  <script type="text/javascript">
    function OptanonWrapper() {}
  </script>

  <!-- Your existing Segment Analytics setup -->
  <script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="gmILwcgOaqputqVmLZKtD0eazHCAeNhR";;analytics.SNIPPET_VERSION="5.2.0";
  analytics.load("gmILwcgOaqputqVmLZKtD0eazHCAeNhR");
  analytics.page();
  }}();
  </script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      line-height: 1.6;
      background: #f5f5f5;
    }
    
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }
    
    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 6px;
      border-left: 4px solid #007cba;
    }
    
    .section h3 {
      margin-top: 0;
      color: #333;
    }
    
    button {
      background: #007cba;
      color: white;
      border: none;
      padding: 12px 20px;
      margin: 5px 10px 5px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0056a3;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    .form-group {
      margin: 10px 0;
    }
    
    input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-right: 10px;
      width: 200px;
    }
    
    .debug-info {
      margin-top: 20px;
      font-family: monospace;
      font-size: 12px;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #e9ecef;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîå Segment Plugin Test Site</h1>
    <p class="subtitle">Test your UTM Campaign and Geo Location plugins</p>
    
    <!-- Plugin Status Section -->
    <div class="section">
      <h3>Plugin Status</h3>
      <div id="plugin-status" class="status info">
        Loading plugins...
      </div>
      <button onclick="checkPluginStatus()">Refresh Status</button>
    </div>

    <!-- UTM Testing Section -->
    <div class="section">
      <h3>üîó UTM Campaign Testing</h3>
      <p>Test UTM campaign source persistence:</p>
      
      <button onclick="simulateUTMPage('google')">Simulate UTM: Google</button>
      <button onclick="simulateUTMPage('facebook')">Simulate UTM: Facebook</button>
      <button onclick="simulateUTMPage('twitter')">Simulate UTM: Twitter</button>
      <br><br>
      <button onclick="clearUTMStorage()">Clear UTM Storage</button>
      <button onclick="showUTMStorage()">Show Stored UTM</button>
      
      <div id="utm-status" class="status" style="display: none;"></div>
    </div>

    <!-- Event Testing Section -->
    <div class="section">
      <h3>üìä Send Test Events</h3>
      <p>Send events to see plugin enrichment:</p>
      
      <div class="form-group">
        <input type="text" id="track-event" placeholder="Event name" value="Button Clicked">
        <button onclick="sendTrackEvent()">Send Track Event</button>
      </div>
      
      <div class="form-group">
        <input type="text" id="user-id" placeholder="User ID" value="test-user-123">
        <input type="text" id="user-email" placeholder="Email" value="test@example.com">
        <button onclick="sendIdentifyEvent()">Send Identify Event</button>
      </div>
      
      <div class="form-group">
        <input type="text" id="page-name" placeholder="Page name" value="Test Page">
        <button onclick="sendPageEvent()">Send Page Event</button>
      </div>
      
      <button onclick="sendGroupEvent()">Send Group Event</button>
      <button onclick="sendAliasEvent()">Send Alias Event</button>
      
      <div id="event-status" class="status" style="display: none;"></div>
    </div>

    <!-- Geo Location Section -->
    <div class="section">
      <h3>üìç Geo Location Testing</h3>
      <p>Test location tracking:</p>
      
      <button onclick="requestLocationPermission()">Request Location Permission</button>
      <button onclick="showLocationData()">Show Current Location Data</button>
      <button onclick="clearGeoStorage()">Clear Geo Storage</button>
      
      <div id="geo-status" class="status" style="display: none;"></div>
    </div>

    <!-- Debug Information -->
    <div class="section">
      <h3>üîß Debug Information</h3>
      <button onclick="showDebugInfo()">Show Debug Info</button>
      <button onclick="openSegmentDebugger()">Open Segment Debugger</button>
      <button onclick="clearAllStorage()">Clear All Plugin Storage</button>
      
      <div id="debug-info" class="debug-info" style="display: none;"></div>
    </div>
  </div>

  <script>
    // Plugin definitions (embedded for easy deployment)
    
    // UTM Campaign Plugin
    window.utmCampaignPersistencePlugin = () => {
      const STORAGE_KEY = 'segment_utm_campaign_source';
      const EXPIRY_DAYS = 30;
      
      const setLocalStorageWithExpiry = (key, value, days) => {
        try {
          const now = new Date();
          const item = {
            value: value,
            expiry: now.getTime() + (days * 24 * 60 * 60 * 1000),
          };
          localStorage.setItem(key, JSON.stringify(item));
        } catch (e) {
          console.warn('UTM Plugin: localStorage not available');
        }
      };
      
      const getLocalStorageWithExpiry = (key) => {
        try {
          const itemStr = localStorage.getItem(key);
          if (!itemStr) return null;
          
          const item = JSON.parse(itemStr);
          const now = new Date();
          
          if (now.getTime() > item.expiry) {
            localStorage.removeItem(key);
            return null;
          }
          
          return item.value;
        } catch (e) {
          return null;
        }
      };
      
      return {
        name: 'UTM Campaign Source Persistence',
        type: 'enrichment',
        version: '1.0.0',
        isLoaded: () => true,
        load: () => Promise.resolve(),
        
        page: (ctx) => {
          const currentCampaignSource = ctx.event.context?.campaign?.source;
          
          if (currentCampaignSource) {
            console.log(`UTM Plugin: Found campaign source: ${currentCampaignSource}`);
            setLocalStorageWithExpiry(STORAGE_KEY, currentCampaignSource, EXPIRY_DAYS);
          } else {
            const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
            if (storedCampaignSource) {
              console.log(`UTM Plugin: Adding stored campaign source: ${storedCampaignSource}`);
              ctx.updateEvent('context.campaign.source', storedCampaignSource);
            }
          }
          
          return ctx;
        },
        
        track: (ctx) => {
          const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
          if (storedCampaignSource && !ctx.event.context?.campaign?.source) {
            ctx.updateEvent('context.campaign.source', storedCampaignSource);
          }
          return ctx;
        },
        
        identify: (ctx) => {
          const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
          if (storedCampaignSource && !ctx.event.context?.campaign?.source) {
            ctx.updateEvent('context.campaign.source', storedCampaignSource);
          }
          return ctx;
        },
        
        group: (ctx) => {
          const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
          if (storedCampaignSource && !ctx.event.context?.campaign?.source) {
            ctx.updateEvent('context.campaign.source', storedCampaignSource);
          }
          return ctx;
        },
        
        alias: (ctx) => {
          const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
          if (storedCampaignSource && !ctx.event.context?.campaign?.source) {
            ctx.updateEvent('context.campaign.source', storedCampaignSource);
          }
          return ctx;
        }
      };
    };

    // Enhanced Geo Location Plugin (Full Version)
    window.geoLocationPlugin = (options = {}) => {
      const config = {
        timeout: options.timeout || 10000,
        maximumAge: options.maximumAge || 300000,
        enableHighAccuracy: options.enableHighAccuracy !== undefined ? options.enableHighAccuracy : true,
        autoRequestPermission: options.autoRequestPermission !== undefined ? options.autoRequestPermission : true,
        cacheLocation: options.cacheLocation !== undefined ? options.cacheLocation : true,
        cacheExpiry: options.cacheExpiry || 1800000,
        preferGPS: options.preferGPS !== undefined ? options.preferGPS : true,
        includeIPData: options.includeIPData !== undefined ? options.includeIPData : true,
        includeISPData: options.includeISPData !== undefined ? options.includeISPData : true,
        includeTimezone: options.includeTimezone !== undefined ? options.includeTimezone : true,
        oncePerSession: options.oncePerSession !== undefined ? options.oncePerSession : false,
        debug: options.debug || false
      };

      let locationData = null;
      let locationPromise = null;
      let permissionDenied = false;
      let sessionLocationCaptured = false;

      const CACHE_KEY = 'segment_enhanced_geo_location';
      const SESSION_KEY = 'segment_enhanced_geo_session_captured';
      
      const log = (message, data) => {
        if (config.debug) {
          console.log(`Enhanced Geo Plugin: ${message}`, data || '');
        }
      };

      // Get comprehensive IP-based location data
      const getIPLocationData = async () => {
        if (!config.includeIPData) return null;
        
        try {
          log('Fetching comprehensive IP location data');
          
          // Use multiple services for comprehensive data
          const responses = await Promise.allSettled([
            fetch('https://ipapi.co/json/'),           // Primary - comprehensive
            fetch('https://ip-api.com/json/'),         // Backup - detailed
            fetch('https://ipinfo.io/json')            // Backup - ISP data
          ]);
          
          let ipData = {};
          
          // Process ipapi.co response (most comprehensive)
          if (responses[0].status === 'fulfilled') {
            const data = await responses[0].value.json();
            if (data.latitude && data.longitude) {
              ipData = {
                latitude: parseFloat(data.latitude),
                longitude: parseFloat(data.longitude),
                city: data.city || null,
                region: data.region || null,
                region_code: data.region_code || null,
                country: data.country_name || null,
                country_code: data.country_code || null,
                country_code_iso3: data.country_code_iso3 || null,
                postal: data.postal || null,
                timezone: data.timezone || null,
                utc_offset: data.utc_offset || null,
                calling_code: data.country_calling_code || null,
                currency: data.currency || null,
                languages: data.languages || null,
                asn: data.asn || null,
                org: data.org || null,
                isp: null, // Will be filled from other sources
                source: 'ipapi.co'
              };
            }
          }
          
          // Enhance with ip-api.com data (better ISP info)
          if (responses[1].status === 'fulfilled') {
            const data = await responses[1].value.json();
            if (data.status === 'success') {
              ipData.isp = ipData.isp || data.isp;
              ipData.org = ipData.org || data.org;
              ipData.as = ipData.as || data.as;
              ipData.mobile = data.mobile || false;
              ipData.proxy = data.proxy || false;
              ipData.hosting = data.hosting || false;
            }
          }
          
          // Enhance with ipinfo.io data
          if (responses[2].status === 'fulfilled') {
            const data = await responses[2].value.json();
            if (data.loc) {
              const [lat, lng] = data.loc.split(',').map(parseFloat);
              ipData.latitude = ipData.latitude || lat;
              ipData.longitude = ipData.longitude || lng;
              ipData.city = ipData.city || data.city;
              ipData.region = ipData.region || data.region;
              ipData.country = ipData.country || data.country;
              ipData.postal = ipData.postal || data.postal;
              ipData.timezone = ipData.timezone || data.timezone;
              ipData.org = ipData.org || data.org;
            }
          }
          
          if (ipData.latitude && ipData.longitude) {
            log('IP location data retrieved', ipData);
            return ipData;
          }
          
        } catch (error) {
          log('IP-based location failed', error);
        }
        
        return null;
      };

      // Get GPS location data
      const getGPSLocation = () => {
        if (!navigator.geolocation || permissionDenied) {
          return Promise.resolve(null);
        }

        return new Promise((resolve) => {
          const options = {
            enableHighAccuracy: config.enableHighAccuracy,
            timeout: config.timeout,
            maximumAge: config.maximumAge
          };

          navigator.geolocation.getCurrentPosition(
            (position) => {
              const gpsData = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude || null,
                altitudeAccuracy: position.coords.altitudeAccuracy || null,
                heading: position.coords.heading || null,
                speed: position.coords.speed || null,
                timestamp: position.timestamp,
                source: 'gps'
              };

              log('GPS location retrieved', gpsData);
              resolve(gpsData);
            },
            (error) => {
              log('GPS location failed', { code: error.code, message: error.message });
              
              if (error.code === 1) {
                permissionDenied = true;
              }
              
              resolve(null);
            },
            options
          );
        });
      };

      // Get timezone data
      const getTimezoneData = () => {
        if (!config.includeTimezone) return {};
        
        try {
          const timezone = Intl.DateTimeFormat().resolvedOptions();
          return {
            timezone: timezone.timeZone,
            timezone_offset: new Date().getTimezoneOffset() * -1, // Minutes from UTC
            locale: navigator.language || null,
            locales: navigator.languages || []
          };
        } catch (error) {
          log('Timezone data failed', error);
          return {};
        }
      };

      // Get connection data
      const getConnectionData = () => {
        try {
          const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          if (connection) {
            return {
              connection_type: connection.effectiveType || null, // 4g, 3g, 2g, slow-2g
              downlink: connection.downlink || null, // Mbps
              rtt: connection.rtt || null, // Round trip time in ms
              save_data: connection.saveData || false
            };
          }
        } catch (error) {
          log('Connection data failed', error);
        }
        return {};
      };

      // Cache management
      const getCachedLocation = () => {
        if (!config.cacheLocation) return null;
        
        try {
          const cached = localStorage.getItem(CACHE_KEY);
          if (!cached) return null;
          
          const data = JSON.parse(cached);
          const now = Date.now();
          
          if (now - data.timestamp > config.cacheExpiry) {
            localStorage.removeItem(CACHE_KEY);
            return null;
          }
          
          log('Using cached location data', data.location);
          return data.location;
        } catch (e) {
          log('Error reading cached location', e);
          return null;
        }
      };

      const setCachedLocation = (location) => {
        if (!config.cacheLocation) return;
        
        try {
          const data = {
            location,
            timestamp: Date.now()
          };
          localStorage.setItem(CACHE_KEY, JSON.stringify(data));
          log('Cached location data', location);
        } catch (e) {
          log('Error caching location', e);
        }
      };

      // Session management
      const wasLocationCapturedThisSession = () => {
        if (!config.oncePerSession) return false;
        return sessionStorage.getItem(SESSION_KEY) === 'true';
      };

      const markLocationCapturedThisSession = () => {
        if (config.oncePerSession) {
          sessionStorage.setItem(SESSION_KEY, 'true');
          sessionLocationCaptured = true;
        }
      };

      // Main location gathering function
      const getCurrentLocation = async () => {
        // Check session limits
        if (config.oncePerSession && wasLocationCapturedThisSession()) {
          log('Location already captured this session, using cached data');
          return locationData;
        }

        // Return existing promise if in progress
        if (locationPromise) {
          return locationPromise;
        }

        // Check cache
        const cached = getCachedLocation();
        if (cached) {
          locationData = cached;
          return cached;
        }

        log('Gathering comprehensive location data...');

        locationPromise = (async () => {
          try {
            const [gpsData, ipData] = await Promise.all([
              config.preferGPS ? getGPSLocation() : Promise.resolve(null),
              getIPLocationData()
            ]);

            // Combine GPS and IP data
            let combinedData = {};

            if (config.preferGPS && gpsData) {
              // Use GPS as primary, IP as enhancement
              combinedData = {
                ...gpsData,
                // Enhance GPS with IP-derived location names
                city: ipData?.city || null,
                region: ipData?.region || null,
                country: ipData?.country || null,
                country_code: ipData?.country_code || null,
                postal: ipData?.postal || null,
                timezone: ipData?.timezone || null,
                isp: ipData?.isp || null,
                org: ipData?.org || null,
                data_source: 'gps_enhanced'
              };
            } else if (ipData) {
              // Use IP data as primary
              combinedData = {
                ...ipData,
                data_source: 'ip'
              };
            }

            // Add timezone data
            const timezoneData = getTimezoneData();
            combinedData = { ...combinedData, ...timezoneData };

            // Add connection data
            const connectionData = getConnectionData();
            combinedData = { ...combinedData, ...connectionData };

            if (combinedData.latitude && combinedData.longitude) {
              locationData = combinedData;
              setCachedLocation(combinedData);
              markLocationCapturedThisSession();
              log('Complete location data gathered', combinedData);
            } else {
              log('No location data available');
              locationData = null;
            }

            locationPromise = null;
            return locationData;
            
          } catch (error) {
            log('Location gathering failed', error);
            locationPromise = null;
            return null;
          }
        })();

        return locationPromise;
      };

      // Format data for Amplitude compatibility
      const formatForAmplitude = (locationData) => {
        if (!locationData) return {};

        // Core Amplitude location format
        const amplitudeLocation = {
          latitude: locationData.latitude?.toString() || null,
          longitude: locationData.longitude?.toString() || null
        };

        // Add optional Amplitude fields
        if (locationData.city) amplitudeLocation.city = locationData.city;
        if (locationData.region) amplitudeLocation.region = locationData.region;
        if (locationData.country) amplitudeLocation.country = locationData.country;
        
        // Add extended data as custom properties
        const extendedData = {};
        
        if (locationData.country_code) extendedData.country_code = locationData.country_code;
        if (locationData.postal) extendedData.postal_code = locationData.postal;
        if (locationData.timezone) extendedData.timezone = locationData.timezone;
        if (locationData.isp) extendedData.isp = locationData.isp;
        if (locationData.org) extendedData.organization = locationData.org;
        if (locationData.connection_type) extendedData.connection_type = locationData.connection_type;
        if (locationData.accuracy) extendedData.gps_accuracy = locationData.accuracy;
        if (locationData.data_source) extendedData.location_source = locationData.data_source;

        return { amplitudeLocation, extendedData };
      };

      // Enrich events with location data
      const enrichEventWithLocation = (ctx) => {
        if (!locationData) return ctx;

        const { amplitudeLocation, extendedData } = formatForAmplitude(locationData);

        // Set core location (matches Amplitude format)
        if (amplitudeLocation.latitude && amplitudeLocation.longitude) {
          ctx.updateEvent('context.location', amplitudeLocation);
        }

        // Add extended location data as properties
        Object.entries(extendedData).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            ctx.updateEvent(`properties.${key}`, value);
          }
        });

        log('Event enriched with comprehensive location data', { amplitudeLocation, extendedData });
        return ctx;
      };

      // Plugin definition
      const plugin = {
        name: 'Enhanced Geo Location Tracking',
        type: 'enrichment',
        version: '2.0.0',
        
        isLoaded: () => true,
        
        load: async () => {
          log('Initializing enhanced geo location plugin', config);
          
          if (config.autoRequestPermission && navigator.geolocation) {
            getCurrentLocation().catch(() => {
              log('Background location gathering failed');
            });
          }
        },

        page: async (ctx) => {
          if (!locationData && config.autoRequestPermission) {
            await getCurrentLocation();
          }
          return enrichEventWithLocation(ctx);
        },

        track: async (ctx) => {
          if (!locationData && config.autoRequestPermission) {
            await getCurrentLocation();
          }
          return enrichEventWithLocation(ctx);
        },

        identify: async (ctx) => {
          if (!locationData && config.autoRequestPermission) {
            await getCurrentLocation();
          }
          return enrichEventWithLocation(ctx);
        },

        group: async (ctx) => {
          if (!locationData && config.autoRequestPermission) {
            await getCurrentLocation();
          }
          return enrichEventWithLocation(ctx);
        },

        alias: async (ctx) => {
          if (!locationData && config.autoRequestPermission) {
            await getCurrentLocation();
          }
          return enrichEventWithLocation(ctx);
        }
      };

      // Public methods
      plugin.requestLocation = () => getCurrentLocation();
      plugin.getCurrentLocation = () => locationData;
      plugin.clearCache = () => {
        localStorage.removeItem(CACHE_KEY);
        sessionStorage.removeItem(SESSION_KEY);
        locationData = null;
        sessionLocationCaptured = false;
        log('Cache cleared');
      };
      plugin.getLocationSummary = () => {
        if (!locationData) return 'No location data available';
        return `${locationData.city || 'Unknown City'}, ${locationData.region || 'Unknown Region'}, ${locationData.country || 'Unknown Country'} (${locationData.data_source || 'unknown source'})`;
      };

      return plugin;
    };

    // Initialize plugins when analytics is ready
    let pluginsLoaded = false;
    let geoPlugin = null;

    window.analytics.ready(async () => {
      try {
        // Register UTM Plugin
        await window.analytics.register(utmCampaignPersistencePlugin());
        console.log('‚úÖ UTM Campaign Plugin registered');
        
        // Register Geo Plugin with debug enabled
        geoPlugin = geoLocationPlugin({ 
          debug: true,
          autoRequestPermission: false, // We'll request manually via button
          preferGPS: true,               // Prefer GPS over IP when available  
          includeIPData: true,           // Include comprehensive IP location data
          includeISPData: true,          // Include ISP and organization data
          includeTimezone: true          // Include timezone information
        });
        await window.analytics.register(geoPlugin);
        console.log('‚úÖ Geo Location Plugin registered');
        
        pluginsLoaded = true;
        updatePluginStatus('success', '‚úÖ Both plugins loaded successfully!');
        
      } catch (error) {
        console.error('‚ùå Plugin loading failed:', error);
        updatePluginStatus('error', `‚ùå Plugin loading failed: ${error.message}`);
      }
    });

    // Utility functions
    function updateStatus(elementId, type, message) {
      const element = document.getElementById(elementId);
      if (element) {
        element.className = `status ${type}`;
        element.innerHTML = message;
        element.style.display = 'block';
        
        // Auto-hide after 5 seconds for success messages
        if (type === 'success') {
          setTimeout(() => {
            element.style.display = 'none';
          }, 5000);
        }
      }
    }

    function updatePluginStatus(type, message) {
      updateStatus('plugin-status', type, message);
    }

    // Button click handlers
    function checkPluginStatus() {
      if (pluginsLoaded) {
        updatePluginStatus('success', '‚úÖ Both plugins are loaded and ready');
      } else {
        updatePluginStatus('info', '‚è≥ Waiting for plugins to load...');
      }
    }

    function simulateUTMPage(source) {
      analytics.page(`Test Page - ${source}`, {}, {
        context: {
          campaign: {
            source: source,
            medium: 'test',
            campaign: 'plugin_test'
          }
        }
      });
      
      updateStatus('utm-status', 'success', `‚úÖ Sent page call with UTM source: ${source}`);
    }

    function sendTrackEvent() {
      const eventName = document.getElementById('track-event').value || 'Button Clicked';
      analytics.track(eventName, {
        buttonId: 'test-button',
        timestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `‚úÖ Sent track event: ${eventName}`);
    }

    function sendIdentifyEvent() {
      const userId = document.getElementById('user-id').value || 'test-user-123';
      const email = document.getElementById('user-email').value || 'test@example.com';
      
      analytics.identify(userId, {
        email: email,
        name: 'Test User',
        testTimestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `‚úÖ Sent identify event for user: ${userId}`);
    }

    function sendPageEvent() {
      const pageName = document.getElementById('page-name').value || 'Test Page';
      analytics.page(pageName, {
        title: pageName,
        testTimestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `‚úÖ Sent page event: ${pageName}`);
    }

    function sendGroupEvent() {
      analytics.group('test-org-456', {
        name: 'Test Organization',
        industry: 'Technology',
        testTimestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', '‚úÖ Sent group event');
    }

    function sendAliasEvent() {
      analytics.alias('new-user-id-789');
      updateStatus('event-status', 'success', '‚úÖ Sent alias event');
    }

    function requestLocationPermission() {
      if (geoPlugin) {
        geoPlugin.requestLocation().then(() => {
          updateStatus('geo-status', 'success', '‚úÖ Location permission requested');
        }).catch(error => {
          updateStatus('geo-status', 'error', `‚ùå Location request failed: ${error.message}`);
        });
      } else {
        updateStatus('geo-status', 'error', '‚ùå Geo plugin not loaded yet');
      }
    }

    function showLocationData() {
      if (geoPlugin) {
        const location = geoPlugin.getCurrentLocation();
        if (location) {
          updateStatus('geo-status', 'success', 
            `üìç Current location: ${location.city || 'Unknown'}, ${location.region || 'Unknown'} (${location.source})`);
        } else {
          updateStatus('geo-status', 'info', 'üìç No location data available yet');
        }
      } else {
        updateStatus('geo-status', 'error', '‚ùå Geo plugin not loaded yet');
      }
    }

    function clearUTMStorage() {
      localStorage.removeItem('segment_utm_campaign_source');
      updateStatus('utm-status', 'success', 'üóëÔ∏è UTM storage cleared');
    }

    function showUTMStorage() {
      const stored = localStorage.getItem('segment_utm_campaign_source');
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          updateStatus('utm-status', 'info', `üì¶ Stored UTM: ${parsed.value} (expires: ${new Date(parsed.expiry).toLocaleString()})`);
        } catch (e) {
          updateStatus('utm-status', 'error', '‚ùå Error reading UTM storage');
        }
      } else {
        updateStatus('utm-status', 'info', 'üì¶ No UTM data stored');
      }
    }

    function clearGeoStorage() {
      if (geoPlugin) {
        geoPlugin.clearCache();
        updateStatus('geo-status', 'success', 'üóëÔ∏è Geo storage cleared');
      }
    }

    function clearAllStorage() {
      localStorage.removeItem('segment_utm_campaign_source');
      localStorage.removeItem('segment_enhanced_geo_location');
      sessionStorage.removeItem('segment_enhanced_geo_session_captured');
      updateStatus('debug-info', 'success', 'üóëÔ∏è All plugin storage cleared');
    }

    function showDebugInfo() {
      const debugInfo = {
        pluginsLoaded: pluginsLoaded,
        analyticsInitialized: window.analytics.initialized,
        utmStored: !!localStorage.getItem('segment_utm_campaign_source'),
        geoStored: !!localStorage.getItem('segment_enhanced_geo_location'),
        userAgent: navigator.userAgent,
        geolocationSupported: !!navigator.geolocation,
        currentUrl: window.location.href,
        connectionInfo: navigator.connection ? {
          effectiveType: navigator.connection.effectiveType,
          downlink: navigator.connection.downlink,
          rtt: navigator.connection.rtt
        } : 'Not available'
      };
      
      const element = document.getElementById('debug-info');
      element.innerHTML = '<pre>' + JSON.stringify(debugInfo, null, 2) + '</pre>';
      element.style.display = 'block';
    }

    function openSegmentDebugger() {
      const writeKey = 'gmILwcgOaqputqVmLZKtD0eazHCAeNhR';
      window.open(`https://app.segment.com/sources/${writeKey}/debugger`, '_blank');
    }

    // Auto-check plugin status on load
    setTimeout(checkPluginStatus, 1000);
  </script>
</body>
</html>
