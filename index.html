<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Segment SDK Ready Test Site</title>
  
  <!-- Your existing OneTrust setup -->
  <script
    src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"
    type="text/javascript"
    charset="UTF-8"
    data-domain-script="01929b9b-c505-7cd6-9ca1-67e5e5aa979e"
  ></script>
  <script type="text/javascript">
    function OptanonWrapper() {}
  </script>

  <!-- Enhanced Segment Analytics setup with SDK loading control -->
  <script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="gmILwcgOaqputqVmLZKtD0eazHCAeNhR";;analytics.SNIPPET_VERSION="5.2.0";
  
  // DON'T CALL analytics.load() or analytics.page() here yet!
  // We'll handle that in our SDK ready function
  }}();
  </script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 1000px;
      margin: 40px auto;
      padding: 20px;
      line-height: 1.6;
      background: #f5f5f5;
    }
    
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }
    
    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 6px;
      border-left: 4px solid #007cba;
    }
    
    .section h3 {
      margin-top: 0;
      color: #333;
    }
    
    button {
      background: #007cba;
      color: white;
      border: none;
      padding: 12px 20px;
      margin: 5px 10px 5px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0056a3;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    .status.warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    
    .form-group {
      margin: 10px 0;
    }
    
    input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-right: 10px;
      width: 200px;
    }
    
    .debug-info {
      margin-top: 20px;
      font-family: monospace;
      font-size: 12px;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #e9ecef;
    }

    .loading-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007cba;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .timeline {
      margin-top: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .timeline-item {
      padding: 5px 0;
      border-left: 2px solid #dee2e6;
      padding-left: 15px;
      margin-bottom: 10px;
    }

    .timeline-item.completed {
      border-left-color: #28a745;
      color: #155724;
    }

    .timeline-item.loading {
      border-left-color: #007cba;
      color: #0c5460;
    }

    .timeline-item.failed {
      border-left-color: #dc3545;
      color: #721c24;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🚀 Segment SDK Ready Test Site</h1>
    <p class="subtitle">Enhanced SDK loading with guaranteed initialization before first page call</p>
    
    <!-- SDK Loading Status Section -->
    <div class="section">
      <h3>📊 SDK Loading Status</h3>
      <div id="sdk-loading-status" class="status info">
        <div class="loading-indicator"></div>
        Initializing SDKs...
      </div>
      <div id="loading-timeline" class="timeline" style="display: none;"></div>
      <button onclick="retryInitialization()">Retry Initialization</button>
      <button onclick="forcePageCall()">Force Page Call (for testing)</button>
    </div>

    <!-- SDK Management Section -->
    <div class="section">
      <h3>🔧 SDK Management</h3>
      <p>Configure which SDKs to wait for before sending the first page call:</p>
      
      <div class="form-group">
        <label><input type="checkbox" id="wait-amplitude" checked> Wait for Amplitude</label>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="wait-ga4" checked> Wait for Google Analytics 4</label>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="wait-facebook" checked> Wait for Facebook Pixel</label>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="wait-mixpanel"> Wait for Mixpanel</label>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="wait-intercom"> Wait for Intercom</label>
      </div>
      
      <div class="form-group">
        <label>Timeout (seconds): <input type="number" id="sdk-timeout" value="10" min="5" max="60" style="width: 80px;"></label>
      </div>
      
      <button onclick="updateSDKConfig()">Update Configuration</button>
    </div>

    <!-- Plugin Status Section -->
    <div class="section">
      <h3>Plugin Status</h3>
      <div id="plugin-status" class="status info">
        Waiting for SDKs to initialize...
      </div>
      <button onclick="checkPluginStatus()">Refresh Status</button>
    </div>

    <!-- Event Testing Section -->
    <div class="section">
      <h3>📊 Send Test Events</h3>
      <p>Send events after SDK initialization:</p>
      
      <div class="form-group">
        <input type="text" id="track-event" placeholder="Event name" value="Button Clicked">
        <button onclick="sendTrackEvent()">Send Track Event</button>
      </div>
      
      <div class="form-group">
        <input type="text" id="user-id" placeholder="User ID" value="test-user-123">
        <input type="text" id="user-email" placeholder="Email" value="test@example.com">
        <button onclick="sendIdentifyEvent()">Send Identify Event</button>
      </div>
      
      <div class="form-group">
        <input type="text" id="page-name" placeholder="Page name" value="Test Page">
        <button onclick="sendPageEvent()">Send Page Event</button>
      </div>
      
      <div id="event-status" class="status" style="display: none;"></div>
    </div>

    <!-- Debug Information -->
    <div class="section">
      <h3>🔧 Debug Information</h3>
      <button onclick="showDebugInfo()">Show Debug Info</button>
      <button onclick="showSDKStatus()">Show SDK Status</button>
      <button onclick="openSegmentDebugger()">Open Segment Debugger</button>
      
      <div id="debug-info" class="debug-info" style="display: none;"></div>
    </div>
  </div>

  <script>
    // Enhanced Analytics Ready Function with SDK Loading Management
    class SegmentSDKManager {
      constructor(config = {}) {
        this.config = {
          timeout: config.timeout || 10000, // 10 seconds default
          debug: config.debug !== false, // Default to true
          requiredSDKs: config.requiredSDKs || [
            'Amplitude (Actions)',
            'Google Analytics 4 (Actions)', 
            'Facebook Pixel (Actions)'
          ],
          retryAttempts: config.retryAttempts || 3,
          retryDelay: config.retryDelay || 2000,
          ...config
        };
        
        this.sdkStatus = new Map();
        this.initializationPromise = null;
        this.isInitialized = false;
        this.firstPageCallMade = false;
        this.startTime = Date.now();
        this.timeline = [];
        
        this.log('SDK Manager initialized', this.config);
        this.addTimelineEvent('SDK Manager initialized', 'completed');
      }
      
      log(message, data) {
        if (this.config.debug) {
          console.log(`[Segment SDK Manager] ${message}`, data || '');
        }
      }
      
      addTimelineEvent(message, status = 'loading') {
        const event = {
          timestamp: Date.now(),
          message,
          status,
          elapsed: Date.now() - this.startTime
        };
        this.timeline.push(event);
        this.updateTimelineUI();
        this.log(`Timeline: ${message} (${status})`);
      }
      
      updateTimelineUI() {
        const timelineEl = document.getElementById('loading-timeline');
        if (!timelineEl) return;
        
        timelineEl.style.display = 'block';
        timelineEl.innerHTML = this.timeline.map(event => 
          `<div class="timeline-item ${event.status}">
            <strong>${event.elapsed}ms:</strong> ${event.message}
          </div>`
        ).join('');
      }
      
      updateLoadingStatus(message, type = 'info') {
        const statusEl = document.getElementById('sdk-loading-status');
        if (statusEl) {
          const indicator = type === 'info' ? '<div class="loading-indicator"></div>' : '';
          statusEl.className = `status ${type}`;
          statusEl.innerHTML = `${indicator}${message}`;
        }
      }
      
      // Check if a specific SDK is loaded
      isSDKLoaded(sdkName) {
        if (!window.analytics?.Analytics?.instance) return false;
        
        const instance = window.analytics.Analytics.instance;
        if (!instance.integrations) return false;
        
        // Check if the integration is loaded and ready
        const integration = Object.values(instance.integrations).find(int => 
          int.name === sdkName || 
          int.options?.name === sdkName ||
          (int.constructor && int.constructor.name.includes(sdkName.replace(/\s+/g, '')))
        );
        
        if (!integration) return false;
        
        // Check if integration is ready (different SDKs have different ready indicators)
        if (typeof integration.ready === 'function') {
          return integration.ready();
        } else if (typeof integration.loaded === 'function') {
          return integration.loaded();
        } else if (integration._ready !== undefined) {
          return integration._ready;
        } else if (integration.initialized !== undefined) {
          return integration.initialized;
        }
        
        // If no specific ready check, assume it's ready if it exists
        return true;
      }
      
      // Get all loaded SDK names
      getLoadedSDKs() {
        if (!window.analytics?.Analytics?.instance?.integrations) return [];
        
        return Object.values(window.analytics.Analytics.instance.integrations)
          .map(int => int.name || int.options?.name || int.constructor?.name || 'Unknown')
          .filter(name => name !== 'Unknown');
      }
      
      // Check if all required SDKs are loaded
      checkAllSDKsLoaded() {
        const loadedSDKs = this.getLoadedSDKs();
        const requiredSDKs = this.config.requiredSDKs;
        
        this.log('Checking SDKs', { required: requiredSDKs, loaded: loadedSDKs });
        
        for (const sdkName of requiredSDKs) {
          const isLoaded = this.isSDKLoaded(sdkName);
          this.sdkStatus.set(sdkName, isLoaded);
          
          if (!isLoaded) {
            this.log(`SDK not ready: ${sdkName}`);
            return false;
          }
        }
        
        this.log('All required SDKs are loaded!', { loadedSDKs });
        return true;
      }
      
      // Wait for all SDKs to load
      async waitForSDKs() {
        return new Promise((resolve, reject) => {
          const startTime = Date.now();
          const checkInterval = 100; // Check every 100ms
          let attempts = 0;
          const maxAttempts = this.config.timeout / checkInterval;
          
          const checker = setInterval(() => {
            attempts++;
            const elapsed = Date.now() - startTime;
            
            if (this.checkAllSDKsLoaded()) {
              clearInterval(checker);
              this.addTimelineEvent(`All SDKs loaded successfully (${attempts} checks)`, 'completed');
              resolve();
            } else if (elapsed >= this.config.timeout) {
              clearInterval(checker);
              const loadedSDKs = this.getLoadedSDKs();
              const missingSDKs = this.config.requiredSDKs.filter(sdk => !this.isSDKLoaded(sdk));
              
              this.addTimelineEvent(`Timeout waiting for SDKs: ${missingSDKs.join(', ')}`, 'failed');
              reject(new Error(`Timeout waiting for SDKs: ${missingSDKs.join(', ')}. Loaded: ${loadedSDKs.join(', ')}`));
            } else {
              // Update status periodically
              if (attempts % 10 === 0) {
                const loadedCount = this.config.requiredSDKs.filter(sdk => this.isSDKLoaded(sdk)).length;
                this.updateLoadingStatus(
                  `Loading SDKs... (${loadedCount}/${this.config.requiredSDKs.length}) - ${elapsed}ms elapsed`
                );
              }
            }
          }, checkInterval);
        });
      }
      
      // Initialize Segment with SDK waiting
      async initialize() {
        if (this.initializationPromise) {
          return this.initializationPromise;
        }
        
        this.initializationPromise = this._doInitialization();
        return this.initializationPromise;
      }
      
      async _doInitialization() {
        try {
          this.addTimelineEvent('Starting Segment Analytics load');
          this.updateLoadingStatus('Loading Segment Analytics...');
          
          // Load Segment Analytics
          window.analytics.load(window.analytics._writeKey);
          
          // Wait for analytics to be ready
          await new Promise((resolve) => {
            window.analytics.ready(resolve);
          });
          
          this.addTimelineEvent('Segment Analytics loaded', 'completed');
          this.updateLoadingStatus('Segment loaded, waiting for destination SDKs...');
          
          // Wait for all required SDKs
          await this.waitForSDKs();
          
          // Register any plugins
          await this.registerPlugins();
          
          // Mark as initialized
          this.isInitialized = true;
          this.addTimelineEvent('All systems ready!', 'completed');
          this.updateLoadingStatus('✅ All SDKs loaded and ready!', 'success');
          
          // Send the first page call
          await this.sendFirstPageCall();
          
          return true;
          
        } catch (error) {
          this.addTimelineEvent(`Initialization failed: ${error.message}`, 'failed');
          this.updateLoadingStatus(`❌ Initialization failed: ${error.message}`, 'error');
          this.log('Initialization failed', error);
          throw error;
        }
      }
      
      async registerPlugins() {
        try {
          this.addTimelineEvent('Registering plugins');
          
          // Register UTM Plugin
          if (window.utmCampaignPersistencePlugin) {
            await window.analytics.register(window.utmCampaignPersistencePlugin());
            this.addTimelineEvent('UTM Plugin registered', 'completed');
          }
          
          // Register Geo Plugin  
          if (window.geoLocationPlugin) {
            const geoPlugin = window.geoLocationPlugin({ 
              debug: this.config.debug,
              autoRequestPermission: false
            });
            await window.analytics.register(geoPlugin);
            this.addTimelineEvent('Geo Plugin registered', 'completed');
          }
          
        } catch (error) {
          this.addTimelineEvent(`Plugin registration failed: ${error.message}`, 'failed');
          this.log('Plugin registration failed', error);
          // Don't throw - plugins are optional
        }
      }
      
      async sendFirstPageCall() {
        if (this.firstPageCallMade) return;
        
        try {
          this.addTimelineEvent('Sending first page call');
          
          // Send the page call
          window.analytics.page();
          
          this.firstPageCallMade = true;
          this.addTimelineEvent('First page call sent successfully', 'completed');
          
        } catch (error) {
          this.addTimelineEvent(`First page call failed: ${error.message}`, 'failed');
          this.log('First page call failed', error);
          throw error;
        }
      }
      
      // Public method to get initialization status
      getStatus() {
        return {
          isInitialized: this.isInitialized,
          firstPageCallMade: this.firstPageCallMade,
          sdkStatus: Object.fromEntries(this.sdkStatus),
          loadedSDKs: this.getLoadedSDKs(),
          requiredSDKs: this.config.requiredSDKs,
          timeline: this.timeline
        };
      }
      
      // Update configuration
      updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        this.log('Configuration updated', this.config);
      }
      
      // Retry initialization
      async retry() {
        this.initializationPromise = null;
        this.isInitialized = false;
        this.firstPageCallMade = false;
        this.sdkStatus.clear();
        this.timeline = [];
        this.startTime = Date.now();
        
        this.addTimelineEvent('Retrying initialization', 'loading');
        return this.initialize();
      }
    }
    
    // Plugin definitions (same as before)
    window.utmCampaignPersistencePlugin = () => {
      const STORAGE_KEY = 'segment_utm_campaign_source';
      const EXPIRY_DAYS = 30;
      
      const setLocalStorageWithExpiry = (key, value, days) => {
        try {
          const now = new Date();
          const item = {
            value: value,
            expiry: now.getTime() + (days * 24 * 60 * 60 * 1000),
          };
          localStorage.setItem(key, JSON.stringify(item));
        } catch (e) {
          console.warn('UTM Plugin: localStorage not available');
        }
      };
      
      const getLocalStorageWithExpiry = (key) => {
        try {
          const itemStr = localStorage.getItem(key);
          if (!itemStr) return null;
          
          const item = JSON.parse(itemStr);
          const now = new Date();
          
          if (now.getTime() > item.expiry) {
            localStorage.removeItem(key);
            return null;
          }
          
          return item.value;
        } catch (e) {
          return null;
        }
      };
      
      return {
        name: 'UTM Campaign Source Persistence',
        type: 'enrichment',
        version: '1.0.0',
        isLoaded: () => true,
        load: () => Promise.resolve(),
        
        page: (ctx) => {
          const currentCampaignSource = ctx.event.context?.campaign?.source;
          
          if (currentCampaignSource) {
            setLocalStorageWithExpiry(STORAGE_KEY, currentCampaignSource, EXPIRY_DAYS);
          } else {
            const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
            if (storedCampaignSource) {
              ctx.updateEvent('context.campaign.source', storedCampaignSource);
            }
          }
          
          return ctx;
        },
        
        track: (ctx) => {
          const storedCampaignSource = getLocalStorageWithExpiry(STORAGE_KEY);
          if (storedCampaignSource && !ctx.event.context?.campaign?.source) {
            ctx.updateEvent('context.campaign.source', storedCampaignSource);
          }
          return ctx;
        }
      };
    };

    window.geoLocationPlugin = (options = {}) => {
      const config = {
        timeout: options.timeout || 10000,
        debug: options.debug || false,
        autoRequestPermission: options.autoRequestPermission !== false
      };

      let locationData = null;

      const getIPLocationData = async () => {
        try {
          const response = await fetch('https://ipapi.co/json/');
          const data = await response.json();
          if (data.latitude && data.longitude) {
            return {
              latitude: parseFloat(data.latitude),
              longitude: parseFloat(data.longitude),
              city: data.city,
              region: data.region,
              country: data.country_name,
              source: 'ip'
            };
          }
        } catch (error) {
          console.warn('IP location failed', error);
        }
        return null;
      };

      const enrichEventWithLocation = (ctx) => {
        if (!locationData) return ctx;
        
        ctx.updateEvent('context.location', {
          latitude: locationData.latitude?.toString(),
          longitude: locationData.longitude?.toString(),
          city: locationData.city,
          region: locationData.region,
          country: locationData.country
        });
        
        return ctx;
      };

      return {
        name: 'Geo Location Tracking',
        type: 'enrichment',
        version: '1.0.0',
        
        isLoaded: () => true,
        
        load: async () => {
          if (config.autoRequestPermission) {
            locationData = await getIPLocationData();
          }
        },

        page: (ctx) => enrichEventWithLocation(ctx),
        track: (ctx) => enrichEventWithLocation(ctx),
        identify: (ctx) => enrichEventWithLocation(ctx)
      };
    };
    
    // Initialize the SDK Manager
    let sdkManager = null;
    
    // Function to get SDK configuration from UI
    function getSDKConfigFromUI() {
      const requiredSDKs = [];
      
      if (document.getElementById('wait-amplitude')?.checked) {
        requiredSDKs.push('Amplitude (Actions)');
      }
      if (document.getElementById('wait-ga4')?.checked) {
        requiredSDKs.push('Google Analytics 4 (Actions)');
      }
      if (document.getElementById('wait-facebook')?.checked) {
        requiredSDKs.push('Facebook Pixel (Actions)');
      }
      if (document.getElementById('wait-mixpanel')?.checked) {
        requiredSDKs.push('Mixpanel');
      }
      if (document.getElementById('wait-intercom')?.checked) {
        requiredSDKs.push('Intercom');
      }
      
      const timeout = (parseInt(document.getElementById('sdk-timeout')?.value) || 10) * 1000;
      
      return { requiredSDKs, timeout };
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async () => {
      const config = getSDKConfigFromUI();
      sdkManager = new SegmentSDKManager(config);
      
      try {
        await sdkManager.initialize();
      } catch (error) {
        console.error('SDK initialization failed:', error);
      }
    });
    
    // UI Event Handlers
    function updateSDKConfig() {
      if (sdkManager) {
        const newConfig = getSDKConfigFromUI();
        sdkManager.updateConfig(newConfig);
        updateStatus('sdk-loading-status', 'info', '✅ Configuration updated');
      }
    }
    
    async function retryInitialization() {
      if (sdkManager) {
        try {
          const config = getSDKConfigFromUI();
          sdkManager.updateConfig(config);
          await sdkManager.retry();
        } catch (error) {
          console.error('Retry failed:', error);
        }
      }
    }
    
    function forcePageCall() {
      if (window.analytics) {
        window.analytics.page('Manual Page Call', {
          manual: true,
          timestamp: new Date().toISOString()
        });
        updateStatus('sdk-loading-status', 'success', '📄 Manual page call sent');
      }
    }
    
    function checkPluginStatus() {
      if (sdkManager) {
        const status = sdkManager.getStatus();
        const statusEl = document.getElementById('plugin-status');
        
        if (status.isInitialized) {
          statusEl.className = 'status success';
          statusEl.innerHTML = `✅ All systems ready! Loaded SDKs: ${status.loadedSDKs.join(', ')}`;
        } else {
          statusEl.className = 'status warning';
          statusEl.innerHTML = `⏳ Still initializing... Loaded: ${status.loadedSDKs.length}/${status.requiredSDKs.length} SDKs`;
        }
      }
    }
    
    // Event sending functions (same as before)
    function sendTrackEvent() {
      if (!sdkManager?.isInitialized) {
        updateStatus('event-status', 'warning', '⚠️ SDKs not ready yet');
        return;
      }
      
      const eventName = document.getElementById('track-event').value || 'Button Clicked';
      window.analytics.track(eventName, {
        buttonId: 'test-button',
        timestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `✅ Sent track event: ${eventName}`);
    }
    
    function sendIdentifyEvent() {
      if (!sdkManager?.isInitialized) {
        updateStatus('event-status', 'warning', '⚠️ SDKs not ready yet');
        return;
      }
      
      const userId = document.getElementById('user-id').value || 'test-user-123';
      const email = document.getElementById('user-email').value || 'test@example.com';
      
      window.analytics.identify(userId, {
        email: email,
        name: 'Test User',
        testTimestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `✅ Sent identify event for user: ${userId}`);
    }
    
    function sendPageEvent() {
      if (!sdkManager?.isInitialized) {
        updateStatus('event-status', 'warning', '⚠️ SDKs not ready yet');
        return;
      }
      
      const pageName = document.getElementById('page-name').value || 'Test Page';
      window.analytics.page(pageName, {
        title: pageName,
        testTimestamp: new Date().toISOString()
      });
      
      updateStatus('event-status', 'success', `✅ Sent page event: ${pageName}`);
    }
    
    function showDebugInfo() {
      if (sdkManager) {
        const status = sdkManager.getStatus();
        const debugInfo = {
          sdkManagerStatus: status,
          analyticsInitialized: window.analytics?.initialized || false,
          analyticsInstance: !!window.analytics?.Analytics?.instance,
          loadedIntegrations: window.analytics?.Analytics?.instance ? 
            Object.keys(window.analytics.Analytics.instance.integrations || {}) : [],
          userAgent: navigator.userAgent,
          currentUrl: window.location.href,
          timestamp: new Date().toISOString()
        };
        
        const element = document.getElementById('debug-info');
        element.innerHTML = '<pre>' + JSON.stringify(debugInfo, null, 2) + '</pre>';
        element.style.display = 'block';
      }
    }
    
    function showSDKStatus() {
      if (sdkManager) {
        const status = sdkManager.getStatus();
        const element = document.getElementById('debug-info');
        
        let html = '<h4>SDK Loading Timeline:</h4>';
        html += '<div class="timeline">';
        
        status.timeline.forEach(event => {
          html += `<div class="timeline-item ${event.status}">
            <strong>${event.elapsed}ms:</strong> ${event.message}
          </div>`;
        });
        
        html += '</div>';
        html += '<h4>SDK Status Details:</h4>';
        html += `<pre>${JSON.stringify(status.sdkStatus, null, 2)}</pre>`;
        
        element.innerHTML = html;
        element.style.display = 'block';
      }
    }
    
    function openSegmentDebugger() {
      const writeKey = 'gmILwcgOaqputqVmLZKtD0eazHCAeNhR';
      window.open(`https://app.segment.com/sources/${writeKey}/debugger`, '_blank');
    }
    
    // Utility function to update status elements
    function updateStatus(elementId, type, message) {
      const element = document.getElementById(elementId);
      if (element) {
        element.className = `status ${type}`;
        element.innerHTML = message;
        element.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (type === 'success') {
          setTimeout(() => {
            element.style.display = 'none';
          }, 5000);
        }
      }
    }
    
    // Auto-check status periodically
    setInterval(() => {
      if (sdkManager && !sdkManager.isInitialized) {
        checkPluginStatus();
      }
    }, 2000);
  </script>
</body>
</html>
